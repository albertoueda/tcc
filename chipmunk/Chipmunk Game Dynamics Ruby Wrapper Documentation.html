<!DOCTYPE html>
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Chipmunk Game Dynamics Ruby Wrapper Documentation</title>
	<link rel="stylesheet" type="text/css" href="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/stylesheet.css">
	</head>
<body>
<p><img src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/logo1_med.png" alt=""> <a href="http://howlingmoonsoftware.com/"><img src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/hms_logo.png" style="float: right;" alt=""></a></p>
<ul>
	<li><a href="#ChipmunkPhysics">Chipmunk Physics</a></li>
	<li><a href="#ChipmunkBasics">Chipmunk Basics</a></li>
	<li><a href="#ChipmunkRubyAPI">Ruby Bindings API</a></li>
	<li><a href="#Vec2">Chipmunk Vectors</a></li>
	<li><a href="#BB">Chipmunk Bounding Boxes</a></li>
	<li><a href="#Body">Chipmunk Rigid Bodies</a></li>
	<li><a href="#Shape">Chipmunk Collision Shapes</a></li>
	<li><a href="#Space">Chipmunk Spaces</a></li>
	<li><a href="#Constraint">Chipmunk Constraints</a></li>
	<li><a href="#ConstraintTypes">Constraint Types</a></li>
	<li><a href="#CollisionDetection">Overview of Collision Detection in Chipmunk</a></li>
	<li><a href="#Callbacks">Callbacks</a></li>
	<li><a href="#Arbiter">Chipmunk Collision Pairs</a></li>
	<li><a href="#Queries">Queries</a></li>
</ul>
<a id="ChipmunkPhysics"></a>
<h1>Chipmunk Physics 5.3.4 Ruby Bindings</h1>
Chipmunk is a 2D rigid body physics library distributed under the <span class="caps">MIT</span> license by Scott Lembcke.
This file contains the documentation of the 
<a href="http://github.com/beoran/chipmunk">
Ruby bindings of Chipmunk</a>
by John Mair and Beoran. It describes how you can use Chipmunk in Ruby.
It is based on the 
<a href="http://files.slembcke.net/chipmunk/release/ChipmunkLatest-Docs/">
original C documentation</a>.
There is also the 
<a href="http://code.google.com/p/chipmunk-physics/">
original project page</a>. Look there for anything that's missing here. 

<a id="ChipmunkBasics"></a>
<h1>Chipmunk Basics</h1>
<h2>Overview</h2>
<p>There are 4 basic objects you will use in Chipmunk.</p>
<ul>
	<li><strong>Body</strong> A Body holds the physical 
properties of an object. (mass, position, rotation, velocity, etc.) It 
does not have a shape by itself. If you’ve done physics with particles 
before, rigid bodies differ in that they are able to rotate.</li>
	<li><strong>Shape:</strong> By attaching Shapes to bodies, 
you can define the a body’s shape. You can attach as many shapes to a 
single body as you need to in order to define a complex shape. Shapes 
contain the surface properties of an object such as how much friction or
 elasticity it has.</li>
	<li><strong>Constraint</strong> Constraints and joints describe how bodies are attached to each other.</li>
	<li><strong>Space</strong> Spaces are the basic simulation unit in 
Chipmunk. You add bodies, shapes and joints to a space, and then update 
the space as a whole.</li>
</ul>
<p>There is often confusion between rigid bodies and their collision 
shapes in Chipmunk and how they relate to sprites. A sprite would be a 
visual representation of an object, while a collision shape is an 
invisible property that defines how objects should collide. Both the 
sprite’s and the collision shape’s position and rotation are controlled 
by a rigid body.</p>
<h2>Initialization</h2>
In these Ruby bindings, Chipmunk is automatically initialized when you do 
<code>require 'chipmunk'</code>

<h2>Memory Management</h2>
<p>
Ruby is garbage collected, so normallly you don't have to worry about this. 
One important exception are objects of the <code>Arbiter</code> class, which 
may only be referenced inside a collision callback. Any data inside the Arbiter
has to be copied out, and no reference to the Arbiter should be held, since
Chipmunk erases the arbiters after calling the collision callback.
</p>
<h2>Error Handling</h2>
<p>
Most methods will raise a Ruby exception when used incorrectly. Otherwise,
methods that may fail to do what they should do, will return self on success
and nil on failure. 
</p>
<p>Some methods in these wrappers, if used incorrectly, may crash Ruby.
This occurs especially when you're using these methods in ways that Chipmunk
does not allow. The underlying C library will sometimes throw an assertion,
which may crash the bindings and Ruby with it. Yes, I know this is annoying,
but I hope to reduce the occurrence of such problems in later versions.
</p>
 
<h2>Basic Types</h2>
<p>These bindings commonly use Ruby Float for calculations.</p>
<p>There are a few functions in the CP module you will probably find very useful:</p>
<dl>
<dt><code>CP.clamp(f, min, max)</code></dt>
<dd>Clamp <code>f</code> to be between <code>min</code> and <code>max</code>.</dd>
<dt><code>CP.flerp(f1, f2, t)</code></dt>
<dd>Linearly interpolate between <code>f1</code> and <code>f2</code>.</dd>
<dt><code>CP.flerpconst(f1, f2, d)</code></dt>
<dd>Linearly interpolate from <code>f1</code> towards <code>f2</code> by no more than <code>d</code>.</dd>
</dl>

<p>Floating point infinity is defined for you as <code>CP::INFINITY</code>, 
and also as <code>Float::INFINITY</code> if your version of Ruby doesn’t define 
it for you.</p>
<p>To represent vectors, Chipmunk defines the <a href="#Vec2">Vec2</a> type 
and a set of operators for working with them.

<a id="ChipmunkRubyAPI"></a>
</p><h1>Chipmunk Ruby Bindings <span class="caps">API</span></h1>
<h2>Main <span class="caps">API</span></h2>
<ul>
  <li><a href="#Vec2">Vec2</a> – Create and manipulate 2D vectors.</li>
	<li><a href="#BB">BB</a> – Create and manipulate 2D axis-aligned bounding boxes.</li>
	<li><a href="#Body">Body</a> – Create and work with rigid bodies.</li>
	<li><a href="#Shape">Shape</a> – Attach collision shapes to rigid bodies.</li>
	<li><a href="#Space">Space</a> –  Create a “space” to put your objects into and simulate them.</li>
	<li><a href="#Constraint">Constraint</a> – Create joints and other constraints.</li>
	<li>Learn about how <a href="#CollisionDetection">Collision Detection</a> in Chipmunk works.</li>
	<li>Learn about Chipmunk’s <a href="#Callbacks">Callback System</a> for receiving collision events and adding custom behavior to your physics.</li>
	<li>Learn about <a href="#Queries">Queries</a>. Point queries and segment queries (ray casting).</li>
</ul>
<a id="Vec2"></a>
<h1>Chipmunk Vectors <code>CP::Vec2</code></h1>

<h2>Class Constants and Constructors</h2>
<dl> 
<dt><code>CP::Vec2</code></dt><dd>2 dimensional vector class.</dd>
<dt><code>CP::Vec2.new(x, y)</code></dt><dd>Allocates a new vector with the given <code>x</code> and <code>y</code> coordinates.</dd>
<dt><code>vec2(x, y)</code></dt><dd>Global convenience function that allocates a new vector with the given <code>x</code> and <code>y</code> coordinates.</dd>
<dt><code>CP::Vec2.for_angle?(a)</code></dt>
<dd>Constructs a unit vector which makes an angle <code>a</code> with the x axis. 
</dd><dt><code>CP::Vec2::ZERO</code></dt><dd>Constant for the zero vector.</dd>
<dt><code></code></dt><dd></dd>
</dl>

<h2>Operators and Methods</h2>
<dl>
<dt><code>CP::Vec2#x</code></dt><dd>X coordinate of vector.</dd>
<dt><code>CP::Vec2#y</code></dt><dd>Y coordinate of vector.</dd>
<dt><code>CP::Vec2#==(vec)</code></dt><dd>Check if two vectors are equal. 
(Be careful when comparing floating point numbers!)</dd>
<dt><code>CP::Vec2#+(vec)</code> <code>CP::Vec22#-(vec)</code></dt>
<dd> Add or subtract two vectors.</dd>
<dt><code>CP::Vec2#@-</code> <code>CP::Vec22#@+</code></dt>
<dd>Negate a vector, or return itself.</dd>
<dt><code>CP::Vec2#*(scalar)</code> <code>CP::Vec22#/(scalar)</code></dt>
<dd>Scalar multiplication and division.</dd>
<dt><code>CP::Vec2#dot(vect)</code></dt>
<dd>Vector dot product.</dd>
<dt><code>CP::Vec2#cross(vect)</code></dt>
<dd>2D vector cross product analog. The cross product of 2D 
vectors results in a 3D vector with only a z component. This function 
returns the magnitude of the z value.</dd>
<dt><code>CP::Vec2#perp</code></dt>
<dd>Returns a perpendicular vector. (90 degree rotation)</dd>
<dt><code>CP::Vec2#nperp</code></dt>
<dd>Returns a perpendicular vector. (-90 degree rotation)</dd>
<dt><code>CP::Vec2#project(vec)</code></dt>
<dd>Returns the vector projection of <code>self</code> onto <code>vec</code>.</dd>
<dt><code>CP::Vec2#rotate(vec)</code></dt>
<dd>Uses complex multiplication to rotate <code>self</code> by <code>vec</code>. Scaling will occur if <code>self</code> is not a unit vector.</dd>
<dt><code>CP::Vec2#unrotate(vec)</code></dt>
<dd>Inverse of <code>CP::Vec2#rotate(vec)</code></dd>
<dt><code>CP::Vec2#length()</code></dt>
<dd>Returns the length of <code>self</code>.</dd>
<dt><code>CP::Vec2#lengthsq()</code></dt>
<dd>Returns the squared length of <code>self</code>. Faster than Vec2#length
when you only need to compare lengths.</dd>
<dt><code>CP::Vec2#lerp(vec, t)</code></dt>
<dd>Linearly interpolate between <code>self</code> and <code>vec</code>.</dd>
<dt><code>CP::Vec2#lerpconst(vec, d)</code></dt>
<dd>Linearly interpolate between <code>self</code> towards <code>vec</code> by 
distance <code>d</code>.</dd>
<dt><code>CP::Vec2#slerp(vec, t)</code></dt>
<dd>Spherically linearly interpolate between <code>self</code> and <code>vec</code>.</dd>
<dt><code>CP::Vec2#slerpconst(vec, a)</code></dt>
<dd>Spherical linearly interpolate between <code>self</code> towards <code>vec</code> by no more than angle <code>a</code> in radians.</dd>
<dt><code>CP::Vec2#normalize</code></dt>
<dd>Returns a normalized copy of <code>self</code>.</dd>
<dt><code>CP::Vec2#normalize_safe</code></dt>
<dd>Returns a normalized copy of <code>self</code>. Protects against 
divide by zero errors. Returns <code>CP::Vec2::ZERO</code> if there vector was already zero.</dd>
<dt><code>CP::Vec2#clamp(len)</code></dt>
<dd>Clamp <code>self</code> to length <code>len</code>.</dd>
<dt><code>CP::Vec2#dist(vec)</code></dt>
<dd>Returns the distance between <code>self</code> and <code>vec</code>.</dd>
<dt><code>CP::Vec2#distsq(vec)</code></dt>
<dd>Returns the squared distance between <code>self</code> and <code>vec</code>. Faster than <code>Vec2#dist(vec)</code> when you only need to compare distances.</dd>
<dt><code>CP::Vec2#near?(vec, dist)</code></dt>
<dd>Returns true if the distance between <code>self</code> and <code>vec</code> is less than <code>dist</code>.</dd>
<dt><code>CP::Vec2#to_angle</code></dt>
<dd>Returns the angular direction <code>self</code> is pointing in (in radians).</dd>
<dt><code>CP::Vec2#to_s</code></dt>
<dd>Returns a string representation of <code>self</code>. Intended mostly for debugging purposes.</dd>
</dl>

<a id="BB"></a>
<h1>Chipmunk Bounding Boxes <code>class CP::BB</code></h1>
<h2>Class Constructors</h2>
<dl>
<dt><code>class CP::BB</code></dt>
<dd>Simple bounding box struct. Stored as left, bottom, right, top values.</dd>
<dt>CP::BB.new(l, b, r, t)</dt>
<dd>Constructor for <code>BB</code> classes. </dd>
</dl>
<h2>Methods</h2>
<dl>
<dt><code>CP::BB#l, CP::BB#b, CP::BB#r, CP::BB#t</code></dt>
<dd>Readers for the bounding box' left, bottom, right and top, respectively.</dd>
<dt><code>CP::BB#intersect(other)</code></dt>
<dd>Returns true if the bounding boxes intersect.</dd>
<dt><code>CP::BB#contain_bb?(other)</code></dt>
<dd>Returns true if <code>self</code> completely contains <code>other</code>.</dd>
<dt><code>CP::BB#contain_vect?(vect)</code></dt>
<dd>Returns true if <code>self</code> contains <code>vec</code>.</dd>
<dt><code>CP::BB#contain?(other)</code></dt>
<dd>Returns true if <code>self</code> contains <code>other</code>.
Convenience method that works for both CP::Vec2 and CP::BB.
</dd>
<dt><code>CP::BB#merge(other)</code></dt>
<dd>Return the minimal bounding box that contains both <code>self</code> and <code>other</code>.</dd>
<dt><code>CP::BB#expand(vec)</code></dt>
<dd>Return the minimal bounding box that contains both <code>self</code> and <code>vec</code>.</dd>
<dt><code>CP::BB#clamp_vect(vec)</code></dt>
<dd>Returns a copy of <code>vec</code> clamped to the bounding box.</dd>
<dt><code>CP::BB#wrap_vect(vec)</code></dt>
<dd>Returns a copy of <code>vec</code> wrapped to the bounding box.</dd>
</dl>

<a id="Body"></a>
<h1>Chipmunk Rigid Bodies <code>CP::Body</code></h1>


<h2>Integration Callbacks</h2>
<dl>
<dt><code>CP::Body#velocity_func() { |body, gravity, damping, dt| ... }</code></dt>
<dd>If a block is passed, this block is called as a custom velocity 
integration function. If no block is passed, the default behavior is restored.
If you wonder if you need this, then you don't. :)</dd>  
<dt><code>CP::Body#position_func() { |body,dt| ... }</code></dt>
<dd>If a block is passed, this block is called as a custom position 
integration function. If no block is passed, the default behavior is restored.
If you wonder if you need this, then you don't. :)</dd>  
</dl>
<h2>CP::Body Accessors</h2>
<ul>
	<li><code>m</code> – <code>Float</code>: Mass of the body.</li>
	<li><code>i</code> – <code>Float</code>: Moment of inertia (MoI or 
sometimes just moment) of the body. The moment is like the rotational 
mass of a body. See below for function to help calculate the moment.</li>
	<li><code>p</code> – <code>CP::Vec2</code>: Position of the body.</li>
	<li><code>v</code> – <code>CP::Vec2</code>: Velocity of the body.</li>
	<li><code>f</code> – <code>CP::Vec2</code>: Current force being applied to the body. <strong>Note:</strong> does not reset automatically as in some physics engines.</li>
	<li><code>a</code> – <code>Float</code>: Current rotation angle of the body in radians.</li>
	<li><code>w</code> – <code>Float</code>: Current rotational velocity of the body.</li>
	<li><code>t</code> – <code>Float</code>: Current torque being applied to the body. <strong>Note:</strong> does not reset automatically as in some physics engines.</li>
	<li><code>rot</code> – <code>CP::Vec2</code>: Cached unit length rotation vector.</li>
	<li><code>v_limit</code> – <code>Float</code>: Maximum speed a body may have after updating it’s velocity.</li>
	<li><code>w_limit</code> – <code>Float</code>: Maximum rotational speed a body may have after updating it’s velocity.</li>
  <li><code>data</code> – <code>Object</code>: The Ruby bindings use this field internally, so it is not available for you use. It returns <code>self</code>, but that is not guaranteed.</li>
	<li><code>object</code> – <code>Object</code>: A user definable 
data object. If you set this to point at the game object the shapes is 
for, then you can access your game object from Chipmunk callbacks.</li>
</ul>
<p>When changing any of a body’s properties, you should also call <code>CP::Body#activate()</code> to make sure that it is not stuck sleeping when you’ve changed a property that should make it move again. <!-- Beoran: make this automatic??? --></p>

<h2>CP::Body Constructors</h2>
<dl>
<dt><code>CP::Body.new(m, i)</code></dt>
<dd>
Constructor for the Body class. <code>m</code> and <code>i</code>
 are the mass and moment of inertia for the body. Guessing the mass for a
 body is usually fine, but guessing a moment of inertia can lead to a 
very poor simulation.</dd>
<dt><code>CP::Body.new_static()</code> <code>CP::_static_body.new()</code></dt>
<dd>
<p>
Creates static bodies with infinite mass and moment of inertia.
</p>
<p>While every <code>CP::Space</code> has a built in static body, this 
is not 
usable from the Ruby API. With this constructor you can make your own 
static bodies. One potential use is in a level editor. By attaching 
chunks of your 
level to static bodies, you can still move and rotate the chunks 
independently 
of each other. Then all you have to do is call <code>CP::Space.rehash_static()</code> to rebuild the static collision detection data when you are done.</p>
<p>For more information on rogue and static bodies, see <a href="#Space">Chipmunk Spaces</a>.</p>
</dd>
</dl>

<h2>Moment of Inertia Helper Functions</h2>
<p>Use the following functions to approximate the moment of inertia for 
your body, adding the results together if you want to use more than one.</p>
<dl>
<dt><code>CP.moment_for_circle(m, r1, r2, offset)</code></dt>
<dd>Calculate the moment of inertia for a hollow circle, <code>r1</code> and <code>r2</code> are the inner and outer diameters in no particular order. <em>(A solid circle has an inner diameter of 0)</em></dd>
<dt><code>CP.moment_for_segment(m, a, b)</code></dt>
<dd>Calculate the moment of inertia for a line segment. The endpoints <code>a</code> and <code>b</code> are relative to the body.</dd>
<dt><code>CP.moment_for_poly(m, verts, offset)</code></dt>
<dd>Calculate the moment of inertia for a solid polygon 
shape assuming it’s center of gravity is at it’s centroid. The offset is
 added to each vertex.</dd>
<dt><code>CP.moment_for_box(m, width, height)</code></dt>
<dd>Calculate the moment of inertia for a solid box centered on the body.</dd>
</dl>
<h2>Area Helper Functions</h2>
<p>Use the following functions to get the area for common Chipmunk shapes if you want to approximate masses.</p>
<dl>
<dt><code>CP.area_for_circle(r1, r2)</code></dt>
<dd>Area of a hollow circle.</dd>
<dt><code>CP.area_for_segment(a, b, r)</code></dt>
<dd>Area of a beveled segment. (Will always be zero if radius is zero)</dd>
<dt><code>CP.area_for_poly(verts)</code></dt>
<dd>Signed area of a polygon shape. Returns a negative number for polygons with a backwards winding.</dd>
</dl>
<h2>Linked Values</h2>
<p>Because several rigid body values are linked to others, (<code>m_inv</code>, <code>i_inv</code>, <code>rot</code>), they cannot be set explicitly. </p>

<h2>Integration Functions</h2>
<dl>
<dt><code>void CP::Body#slew(pos, dt)</code></dt>
<dd>Modify the velocity of the body so that it will move to 
the specified absolute coordinates in the next time step. Intended for 
objects that are moved manually with a custom velocity integration 
function.</dd>
<dt><code>void CP::Body#update_velocity(body, gravity, damping, dt)</code></dt>
<dd>Default rigid body velocity integration function. Updates the velocity of the body using Euler integration.</dd>
<dt><code>void CP::Body#update_position(body, dt)</code></dt>
<dd>Default rigid body position integration function. 
Updates the position of the body using Euler integration. Unlike the 
velocity function, it’s unlikely you’ll want to override this function. 
If you do, make sure you understand it’s source code as it’s an 
important part of the collision/joint correction process.</dd>
</dl>
<h2>Coordinate Conversion Functions</h2>
<dl>
<dt><code>CP::Body#local2world(vec)</code></dt>
<dd>Convert from body local coordinates to world space coordinates.</dd>
<dt><code>CP::Body#world2local(body, vex)</code></dt>
<dd>Convert from world space coordinates to body local coordinates.</dd>
</dl>

<h2>Applying Forces and Torques</h2>
<dl>
<dt><code>CP::Body#apply_impulse(j, r)</code></dt>
<dd>Apply the impulse <code>j</code> to <code>body</code> at a relative offset <code>r</code> from the center of gravity. Both <code>r</code> and <code>j</code> are in world coordinates. <code>r</code> is relative to the position of the body, but not the rotation. Many people get tripped up by this.</dd>
<dt><code>CP::Body#reset_forces</code></dt>
<dd>Zero both the forces and torques accumulated on <code>self</code>.</dd>
<dt><code>CP::Body#apply_force(f, r)</code></dt>
<dd>Apply (accumulate) the force <code>f</code> on <code>body</code> at a <strong>relative offset (important!)</strong> <code>r</code> from the center of gravity. Both <code>r</code> and <code>f</code> are in world coordinates.</dd>
</dl>

<h2>Sleeping Functions</h2>
<p>See Chipmunk Spaces CP::Space for more information on Chipmunk’s sleeping feature.</p>
<dl>
<dt><code>CP::Body#sleeping?</code></dt>
<dd>Returns true if <code>body</code> is sleeping, false if not.</dd>
<dt><code>CP::Body#sleep_with_group(group)</code></dt>
<dd><p>When objects in Chipmunk sleep, they sleep as a group of
 all objects that are touching or jointed together. When an object is 
woken up, all of the objects in it’s group are woken up. Calling 
CP::Body#sleep_with_group(group) forces a body to fall asleep immediately. If <code>group</code> is <code>nil</code>,
 a new group will be created. If group is another sleeping Body, it will
 be added to that body’s group. It is an error to specify a non-sleeping
 Body for <code>group</code>. Make sure everything is set up before 
calling this method. Calling a setter function or adding/removing a 
shape or constraint will cause the body to be woken up again. Also, this
 function must not be called from a collision handler or query callback.
 Use a post-step callback instead.</p>
<p>An example of how this could be used is to set up a piles of boxes 
that a player can knock over. Creating the piles and letting them fall 
asleep normally would work, but it means that all of the boxes would 
need to be simulated until they fell asleep. This could be slow if you 
had a lot of piles. Instead you can force them to sleep and start the 
game with the boxes already sleeping.</p>
<p>Another example would be collapsing platforms. You could create a 
sleeping object that is suspended in the air. As soon as the player 
comes along to jump on it, it wakes up and starts falling. In this case,
 it would be impossible to have the platform fall asleep naturally.</p>
</dd>
<dt><code>CP::Body#sleep_alone</code></dt>
<dd>Equivalent to calling <code>CP::Body#sleep_with_group(nil)</code>. 
It forces <code>body</code> to fall asleep and creates a new group for it. 
The name <code>sleep_alone</code> was chosen because <code>sleep</code> is part 
of Ruby's Kernel module...
</dd>
<dt><code>void CP::Body#activate</code></dt>
<dd>Wake <code>self</code> up so that it starts actively 
simulating again if it’s sleeping, or reset the idle timer if it’s 
active. In Chipmunk 5.3.4 and up, you can call this function from a 
collision or query callback. In previous versions this was an error.</dd>
</dl>
<h2>Misc Functions</h2>
<dl>
<dt><code>CP::Body#static?</code></dt>
<dd>Returns true if <code>self</code> is a static body. (CP::_static_body or a 
static rogue body)</dd>
<dt><code>CP::Body#rogue?()</code></dt>
<dd>Returns true if <code>self</code> has never been added 
to a space. Though shapes attached to this body may still be added to a 
space. For more information on rogue and static bodies, see <a href="#CP::Space">Chipmunk Spaces</a>.</dd>
<dt><code>CP::Bool CP::Body#sleeping?()</code></dt>
<dd>Returns true if <code>self</code> is sleeping.</dd>
</dl>

<h2>Notes</h2>
<ul>
	<li>Use forces to modify the rigid bodies if possible. This will be the most stable.</li>
	<li>Modifying a body’s velocity shouldn’t necessarily be avoided, but 
applying large changes every frame can cause strange results in the 
simulation. Experiment freely, but be warned.</li>
	<li><strong>Don’t</strong> modify a body’s position every step unless 
you really know what you are doing. Otherwise you’re likely to get the 
position/velocity badly out of sync.</li>
</ul>

<a id="Shape"></a>
<h1>Chipmunk Collision Shapes <code>CP::Shape</code></h1>
<p>There are currently 3 collision shape types:</p>
<ul>
	<li><strong>Circles</strong>: Fastest and simplest collision shape.</li>
	<li><strong>Line segments</strong>: Meant mainly as a static shape. 
They can be attached to moving bodies, but they don’t currently generate
 collisions with other line segments. Can be beveled in order to give 
them a thickness.</li>
	<li><strong>Convex polygons</strong>: Slowest, but most flexible collision shape.</li>
</ul>
<p>You can add multiple shapes to a body. This should give you the 
flexibility to make any shape you want as well providing different areas
 of the same object with different friction, elasticity or callback 
values.</p>
<h2>Accessors</h2>
<p>All collision shapes include the CP::Shape module. Chipmunk shapes are meant to be opaque types.
</p><ul>
	<li><code>body</code> – <code>CP::Body</code>: The rigid body the shape is attached to.</li>
	<li><code>bb_raw</code> – <code>CP::BB</code>: The bounding box of the shape. Only guaranteed to be valid after <code>CP::Shape#bb()</code> or <code>CP::Space#step()</code> is called. Moving a body that a shape is connected to does not update it’s bounding box.</li>
	<li><code>sensor</code> – <code>true or false</code>: A Boolean value if this shape is a sensor or not. Sensors only call collision callbacks, and never generate real collisions.</li>
	<li><code>e</code> – <code>Float</code>: Elasticity of the shape. A 
value of 0.0 gives no bounce, while a value of 1.0 will give a “perfect”
 bounce. However due to inaccuracies in the simulation using 1.0 or 
greater is not recommended however. <em>See the notes at the end of the section.</em></li>
	<li><code>u</code> – <code>Float</code>: Friction coefficient. Chipmunk uses the Coulomb friction model, a value of 0.0 is frictionless. <a href="http://www.roymech.co.uk/Useful_Tables/Tribology/co_of_frict.htm">Tables of friction coefficients</a>. <em>See the notes at the end of the section.</em></li>
	<li><code>surface_v</code> – <code>CP::Vec2</code>: The surface velocity 
of the object. Useful for creating conveyor belts or players that move 
around. This value is only used when calculating friction, not resolving
 the collision.</li>
	<li><code>collision_type</code> – <code>Symbol</code>: You can assign 
symbols as collision types types to Chipmunk collision shapes that 
trigger callbacks when objects of certain types touch. See the <a href="#Callbacks">callbacks section</a> or an <a href="http://files.slembcke.net/chipmunk/release/_chipmunk_latest-Docs/examples.html#_collision_callbacks">example</a> for more information.</li>
	<li><code>group</code> – <code>Fixnum</code>: Shapes in the 
same non-zero group do not generate collisions. Useful when creating an 
object out of many shapes that you don’t want to self collide. Defaults 
to <code>CP::NO_GROUP</code>.</li>
	<li><code>layers</code> – <code>Fixnum</code>: Shapes only collide if they are in the same bit-planes. i.e. <code>(a-&gt;layers &amp; b-&gt;layers) != 0</code> By default, a shape occupies all bit-planes. <a href="http://en.wikipedia.org/wiki/Mask_%28computing%29#top">Wikipedia</a> has a nice article on bit masks if you are unfamiliar with how to use them. Defaults to <code>CP::ALL_LAYERS</code>.</li>
	<li><code>data</code> – <code>Object</code>: The Ruby bindings use this field internally, so it is not available for you use. It returns <code>self</code>, but that is not guaranteed.</li>
  <li><code>object</code> – <code>Object</code>: A user definable 
data object. If you set this to point at the game object the shapes is 
for, then you can access your game object from Chipmunk callbacks.</li>
</ul>
<h2>Filtering Collisions</h2>
<p>Chipmunk has two primary means of ignoring collisions: groups and layers.</p>
<p>Groups are meant to ignore collisions between parts on a complex 
object. A rag doll is a good example. When jointing an arm onto the 
torso, you’ll want them to allow them to overlap. Groups allow you to do
 exactly that. Shapes that have the same group don’t generate 
collisions. So by placing all of the shapes in a rag doll in the same 
group, you’ll prevent it from colliding against other parts of itself.</p>
<p>Layers allow you to separate collision shapes into mutually exclusive
 planes. Shapes can be in more than one layer, and shapes only collide 
with other shapes that are in at least one of the same layers. As a 
simple example, say shape A is in layer 1, shape B is in layer 2, and 
shape C is in layer 1 and 2. Shape A and B won’t collide with each 
other, but shape C will collide with both A and B.</p>
<p>Layers can also be used to set up rule based collisions. Say you have
 four types of shapes in your game. The player, the enemies, player 
bullets and enemy bullets. The are that the player should collide with 
enemies, and bullets shouldn’t collide with the type (player or enemy) 
that fired them. Making a chart would look like this:</p>
<table>
	<tbody><tr>
		<td> </td>
		<td> Player </td>
		<td> Enemy </td>
		<td> Player Bullet </td>
		<td> Enemy Bullet </td>
	</tr>
	<tr>
		<td> Player </td>
		<td> – </td>
		<td> (1) </td>
		<td>  </td>
		<td> (2) </td>
	</tr>
	<tr>
		<td> Enemy </td>
		<td> – </td>
		<td> – </td>
		<td> (3) </td>
		<td>  </td>
	</tr>
	<tr>
		<td> Player Bullet </td>
		<td> – </td>
		<td> – </td>
		<td> – </td>
		<td>  </td>
	</tr>
	<tr>
		<td> Enemy Bullet </td>
		<td> – </td>
		<td> – </td>
		<td> – </td>
		<td> – </td>
	</tr>
</tbody></table>
<p>The ‘-’s are for redundant spots in the chart, and the numbers are 
spots where types should collide. You can use a layer for rule that you 
want to define. Then add the layers to each type: The player should be 
in layers 1 and 2, the enemy should be in layers 1 and 3, the player 
bullets should be in layer 3, and the enemy bullets should be in layer 
2. Treating layers as rules this way, you can define up to 32 rules. The
 default <code>layer</code> type has a resolution of 32 bits on most systems.</p>
<p>There is one last way of filtering collisions using collision handlers. See the <a href="#Callbacks">section on callbacks</a>
 for more information. While collision handlers can be more flexible, 
they are also the slowest method. So you try to use groups or layers 
first.</p>
<h2>Shape Operations</h2>
<dl>
<dt><code>CP::Shape#cache_bb()</code>, <code>CP::Shape#bb()</code></dt>
<dd>Updates and returns the bounding box of <code>shape</code> and returns it.</dd>
<dt><code>void CP::Shape.reset_id_counter</code></dt>
<dd>Chipmunk keeps a counter so that every new shape is 
given a unique hash value to be used in the spatial hash. Because this 
affects the order in which the collisions are found and handled, you can
 reset the shape counter every time you populate a space with new 
shapes. If you don’t, there might be (very) slight differences in the 
simulation.</dd>
</dl>
<h2>Working With Circle Shapes</h2>
<dl>
<dt><code>CP::Shape::Circle.new(body, radius, offset)</code></dt>
<dd><code>body</code> is the body to attach the circle to, <code>offset</code>
is the offset from the body’s center of gravity in body local coordinates.
<strong>Note:</strong> Due to a bug in the upstream Chipmunk 5.3.4, calling
<code>CP::Shape::Circle.new</code>, or any of the CP::Shape::XXX.new
constructors with incorrect arguments will crash your program.
This will be fixed in a later version of Chipmunk.
</dd>
<dt><code>CP::Shape::Circle#offset, CP::Shape::Circle#radius</code></dt>
<dd>Getters for circle shape properties.</dd>
</dl>
<h2>Working With Segment Shapes</h2>
<dl>  
<dt><code>CP::Shape::Segment.new(body, veca, vecb, radius)</code></dt>
<dd><code>body</code> is the body to attach the segment to, <code>veca</code>
and <code>vecb</code> are the endpoints, and <code>radius</code> is the thickness of the segment.</dd>
<dt><code>CP::Shape::Segment#a(CP::Shape *shape), 
CP::Shape::Segment#b(CP::Shape *shape), 
CP::Shape::Segment#normal(CP::Shape *shape), 
CP::Shape::Segment#radius(CP::Shape *shape)</code></dt>
<dd>Getters for segment shape properties.</dd>
</dl>
<h2>Working With Polygon Shapes</h2>
<dl>
<dt><code>CP::Shape::Poly.valid?(verts)</code></dt>
<dd>Checks if <code>verts</code>, which should be an array of CP::Vec2 points,
will form a valid, closed polygon array. Useful in conjunction with
<code>CP::Shape::Poly.new</code></dd>
  
<dt><code>CP::Shape::Poly.new(body, verts, offset)</code></dt>
<dd><code>body</code> is the body to attach the poly to, <code>verts</code> is an array of <code>CP::Vec2</code> objects defining a convex hull with a clockwise winding, <code>offset</code>
 is the offset from the body’s center of gravity in body local 
coordinates. An exception will be thrown the vertexes are not convex or 
do not have a clockwise winding. <strong>Note:</strong> Due to an upstream bug,
using incorrect <code>verts</code> will cause a crash.</dd>
<dt><code>CP::Shape::Poly.num_verts, CP::Shape::Poly.vert(index)</code></dt>
<dd>Getters for poly shape properties. Passing an index that does not exist will return nil.</dd>
</dl>
<h2>Poly Shape Helper Functions</h2>
<dl>
<dt><code>CP::centroid_for_poly(verts) TODO!</code></dt>
<dd>Calculate the centroid for a polygon.</dd>
<dt><code>void CP::recenter_poly(verts)</code></dt>
<dd>Center a polygon to (0,0). Subtracts the centroid from each vertex.</dd>
</dl>
<h2>Modifying CP::Shapes</h2>
<p>The short answer is that you can’t because the changes would be only 
picked up as a change to the position of the shape’s surface.
The long answer is that with the following functions, since version 5.3.4.1
of the bindings, you can, but the results will probably not be what you expect.
</p>
<p>The following operations are "unsafe", because they may reduce the physical
accuracy or numerical stability of the simulation, but will not cause crashes.
The prime example is mutating collision shapes. Chipmunk does not support
this directly. Mutating shapes using this API will caused objects in contact
to be pushed apart using Chipmunk's overlap solver, but not using real
persistent velocities. Probably not what you meant, but perhaps close enough.
</p>
<dl>
<dt><code>CP::Shape::Circle#set_radius!(r)</code></dt>
<dd>Sets the radius of the circle to <code>r</code>.</dd>
<dt><code>CP::Shape::Circle#set_offset!(offset)</code></dt>
<dd>Sets the offset from center of the circle to <code>offset</code>.</dd>
<dt><code>CP::Shape::Segment#set_radius!(r)</code></dt>
<dd>Sets the radius of the segment to <code>r</code>.</dd>
<dt><code>CP::Shape::Segment#set_endpoints!(veca, vecb)</code></dt>
<dd>Sets the endpoints of the segment to <code>veca</code> and
<code>vecb</code>.</dd>
<dt><code>CP::Shape::Poly#set_verts!(verts, offset)</code></dt>
<dd>Sets the vertices and offset of the polygon. <code>verts</code> is
an Array of <code>CP::Vec2</code> objects defining a convex hull with a
clockwise winding, <code>offset</code> is the offset from the body’s center
of gravity in body local coordinates. An ArgumentError will be raised if the
vertexes are not convex or do not have a clockwise winding.</dd>
</dl>
<h2>Notes</h2>
<ul>
	<li>You can attach multiple collision shapes to a rigid body. This 
should allow you to create almost any shape you could possibly need.</li>
	<li>Shapes attached to the same rigid body will never generate 
collisions. You don’t have to worry about overlap when attaching 
multiple shapes to a rigid body.</li>
	<li>The amount of elasticity applied during a collision is determined 
by multiplying the elasticity of both shapes together. The same is done 
for determining the friction. If you want to override this default 
behavior, you can do so inside of a preSolve collision callback. See the
 <a href="#ChipmunkCallbacks">Chipmunk Callbacks</a> section for more information.</li>
	<li>Make sure you add both the body and it’s collision shapes to a 
space. The exception is when you want to have a static body or a body 
that you integrate yourself. In that case, only add the shape.</li>
</ul>
<a id="Space"></a>
<h1>Chipmunk Spaces <code>CP::Space</code></h1>
<p>Spaces in Chipmunk are the basic unit of simulation. You add rigid 
bodies, shapes and constraints to it and then step them forward through 
time.</p>
<h2>What Are Iterations, and Why Should I care?</h2>
<p>Chipmunk uses an iterative solver to figure out the forces between 
objects in the space. What this means is that it builds a big list of 
all of the collisions, joints, and other constraints between the bodies 
and makes several passes over the list considering each one 
individually. The number of passes it makes is the iteration count, and 
each iteration makes the solution more accurate. If you use too many 
iterations, the physics should look nice and solid, but may use up too 
much <span class="caps">CPU</span> time. If you use too few iterations, 
the simulation may seem mushy or bouncy when the objects should be 
solid. Setting the number of iterations lets you balance between <span class="caps">CPU</span> usage and the accuracy of the physics. Chipmunk’s default of 10 iterations is sufficient for most simple games.</p>
<h2>Rogue and Static Bodies</h2>
<p>Rogue bodies are bodies that have not been added to the space, but 
are referenced from shapes or joints. Rogue bodies are a common way of 
controlling moving elements in Chipmunk such as platforms. As long as 
the body’s velocity matches the changes to it’s position, there is no 
problem with doing this. Most games will not need rogue bodies however.</p>
<p>In previous versions, Chipmunk used infinite mass rogue bodies to 
attach static shapes to. Creating and maintaining your own body for this
 is no longer necessary in C as each space has it’s own body for attaching 
static shapes to.</p>
<p>This body is marked as being a <em>static body</em>. A
 static body allows other objects resting on or jointed to it to fall 
asleep even though it does not fall asleep itself.</p>
<p> In Ruby, however, it might be a good idea to use your own static shapes, 
as the built-in static Shape of the Space is not so useful. Additional static 
bodies can be created using <code>CP::StaticBody.new()</code> or <code>CP::Body.new_static()</code>.
 Objects resting on or jointed to rogue bodies can never fall asleep. 
This is because the purpose of rogue bodies are to allow the programmer 
to move or modify them at any time. Without knowing when they will move,
 Chipmunk has to assume that objects cannot fall asleep when touching 
them.</p>
<h2>Static Shapes</h2>
<p>Chipmunk optimizes collision detection against shapes that do not 
move. There are two ways that Chipmunk knows a shape is static.</p>
<p>The first is automatic. When adding or removing shapes attached to 
static bodies, Chipmunk knows to handle them specially and you just use 
the same functions as adding regular dynamic shapes, <code>CP::Space.add_shape()
</code> and <code>CP::Space.remove_shape()</code>.</p>
<p>The second way is to explicitly tag shapes as static using
<code>CP::Space.add_static_shape()</code>.
 This is rarely needed, but say for instance that you have a rogue body 
that seldomly moves. In this case, adding a shape attached to it as a 
static shape and updating it only when the body moves can increase 
performance. Shapes added this way must be removed by calling
<code>CP::Space.remove_static_shape()</code>.</p>
<p>Because static shapes aren’t updated automatically, you must let 
Chipmunk know that it needs to update the static shapes. You can update 
all of the static shapes at once using <code>CP::Space#rehash_static()
</code> or individual shapes using <code>CP::Space#rehash_shape</code>.
If you find yourself rehashing static bodies often, you should be adding them
normally using <code>CP::Space#add_shape</code> instead.</p>
<h2>Sleeping</h2>
<p>New in Chipmunk 5.3 is the ability of spaces to disable entire groups of
objects that have stopped moving to save <span class="caps">CPU</span>
 time as well as battery life. In order to use this feature you must do 2
 things. The first is that you must attach all your static geometry to 
static bodies. Objects cannot fall asleep if they are touching a 
non-static rogue body even if it’s shapes were added as static shapes. 
The second is that you must enable sleeping explicitly by choosing a 
time threshold value for <code>CP::Space#sleep_time_threshold</code>. If you do not set <code>CP::Space#idle_speed_threshold</code> explicitly, a value will be chosen automatically based on the current amount of gravity.</p>
<h2>Accessors</h2>
<ul>
	<li><code>iterations</code> – <code>Fixnum</code>: Allow you to control the accuracy of the solver. Defaults to 10. See the section on iterations above for an explanation.</li>
	<li><code>gravity</code> – <code>CP::Vec2</code>: Global gravity applied to the space. Defaults to <code>CP::vzero</code>. Can be overridden on a per body basis by writing custom integration functions.</li>
	<li><code>damping</code> – <code>Float</code>: Amount of viscous 
damping to apply to the space. A value of 0.9 means that each body will 
lose 10% of it’s velocity per second. Defaults to 1. Like <code>gravity</code> can be overridden on a per body basis.</li>
	<li><code>idle_speed</code> – <code>Float</code>: Speed 
threshold for a body to be considered idle. The default value of 0 means
 to let the space guess a good threshold based on gravity.</li>
	<li><code>sleep_time</code> – <code>Float</code>: Time a group of bodies must remain idle in order to fall asleep. The default value of <code>INFINITY</code> disables the sleeping algorithm.</li>
<!-- NOTE: this is not supported in the Ruby Bindings
<li><code>staticBody</code> – <code>CP::Body</code>: A statically allocated infinite mass body that the space uses to substitute for <span class="caps">NULL</span> bodies on shapes and constraints. Set the <code>space-&gt;staticBody.data</code> pointer to something helpful if you want to have some context from within callbacks.</li>
-->
</ul>
<h2>Constructors</h2>
<dl>
<dt><code>CP::Space.new()</code></dt>
<dd>Returns a new Space object.</dd>
</dl>
<h2>Methods</h2>
<dl>
<dt><code>CP::Space#add_shape(shape)
void CP::Space#add_static_shape(shape)
void CP::Space#add_body(body)
void CP::Space#add_constraint(constraint)
void CP::Space#remove_shape(shape)
void CP::Space#remove_static_shape(shape)
void CP::Space#remove_body(body)
void CP::Space#remove_constraint(constraint)</code></dt>
<dd>These functions add and remove shapes, bodies and constraints from
<code>space</code>. They return the object removed from the space, or <code>
nil</code> if the object in question was already removed from or never had been
added to the space. See the section on Static Shapes above for an explanation
of what a static shape is and how it differs from a normal shape. Also, you
cannot call the any of these functions from within a callback other than a 
post-step callback (which is different than a post-solve callback!). 
Attempting to add or remove objects from the space while <code>CP::Space#step
</code> is still executing will most likely crash your application!
See the <a href="#Callbacks">callbacks section</a> for more information.</dd>
</dl>
<h2>Misc</h2>
<dl>
<dt><code>void CP::Space#activate_touching(shape)</code></dt>
<dd>Perform a query for all shapes touching <code>shape</code> and call
<code>CP::Body#activate</code>
 on them. This is useful when you need to move a shape explicitly. 
Waking shapes touching the moved shape prevents objects from sleeping 
when the floor is moved or something similar. You only need to do this 
when changing the shape of an existing shape or moving a static shape. 
Most other methods of moving a shape automatically would wake up other 
touching objects.</dd>
</dl>
<h2>Spatial Hash Management Functions</h2>
<p>Chipmunk uses a spatial hash to accelerate it’s collision detection. 
While it’s not necessary to interact with the hash directly. The current
 <span class="caps">API</span> does expose some of this at the space level to allow you to tune it’s performance.</p>
<dl> 
<dt><code>void CP::Space#resize_static_hash(dim, count)
CP::Space#resize_active_hash(dim, count)</code></dt>
<dd><p>The spatial hash data structures used by Chipmunk’s collision detection are fairly size sensitive. <code>dim</code> is the size of the hash cells. Setting <code>dim</code> to the average collision shape size is likely to give the best performance. Setting <code>dim</code>
 too small will cause the shape to be inserted into many cells, setting 
it too low will cause too many objects into the same hash slot.</p>
<p><code>count</code> is the <em>suggested</em> minimum number of cells 
in the hash table. If there are too few cells, the spatial hash will 
return many false positives. Too many cells will be hard on the cache 
and waste memory. the  Setting <code>count</code> to ~10x the number of objects in the space is probably a good starting point. Tune from there if necessary. By default, <code>dim</code> is 100.0, and <code>count</code>
 is 1000. The new demo program has a visualizer for the static hash. You
 can use this to get a feel for how to size things up against the 
spatial hash.</p>
<p>Using the spatial has visualization in the demo program you can see 
what I mean. The grey squares represent cells in the spatial hash. The 
darker the cell, the more objects have been mapped into that cell. A 
good <code>dim</code> size is when your objects fit nicely into the grid:</p>
<p><img src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/hash_just_right.png" alt=""></p>
<p>Notice the light grey meaning that each cell doesn’t have too many objects mapped onto it.</p>
<p>When you use too small a size, Chipmunk has to insert each object into a lot of cells. This can get expensive.</p>
<p><img src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/hash_too_small.png" alt=""></p>
<p>Notice that the grey cells are very small compared to the collision shapes.</p>
<p>When you use too big of a size, a lot of shapes will fit into each 
cell. Each shape has to be checked against every other shape in the 
cell, so this makes for a lot of unnecessary collision checks.</p>
<p><img src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/hash_too_big.png" alt=""></p>
<p>Notice the dark grey cells meaning that many objects are mapped onto them.</p></dd>
<dt><code>CP::Space#rehash_static()</code></dt>
<dd>Rehashes the shapes in the static spatial hash. You must
 call this if you move any static shapes or Chipmunk won’t update their 
collision detection data.</dd>
<dt><code>CP::Space#rehash_shape(shape)</code></dt>
<dd>Update an individual static shape that has moved.</dd>
</dl>
<h2>Simulating the Space</h2>
<dl>
<dt><code>void CP::Space#step(dt)</code></dt>
<dd>Update the space for the given time step. Using a fixed time step is <em>highly</em>
 recommended. Doing so will increase the efficiency of the contact 
persistence, requiring an order of magnitude fewer iterations and <span class="caps">CPU</span> usage.</dd>
</dl>
<h2>Notes</h2>
<ul>
	<li>When removing objects from the space, make sure you remove any 
other objects that reference it. For instance, when you remove a body, 
remove the joints and shapes attached to it.</li>
	<li>The number of iterations, and the size of the time step determine 
the quality of the simulation. More iterations, or smaller time steps 
increase the quality. Keep in mind that higher quality also means higher
 <span class="caps">CPU</span> usage.</li>
	<li>Because static shapes are only rehashed when you request it, it’s possible to use a much higher <code>count</code> argument to <code>CP::Space.resize_static_hash(dim, count)</code> than to <code>CP::Space.resize_active_hash(dom, count)</code>. Doing so will use more memory but can improve performance if you have a lot of static shapes.</li>
</ul>
<a id="Constraint"></a>
<h1>Chipmunk Constraints <code>CP::Constraint</code></h1>
<p>A constraint is something that describes how two bodies interact with
 each other. (how they constrain each other) Constraints can be simple 
joints that allow bodies to pivot around each other like the bones in 
your body, or they can be more abstract like the gear joint or motors.</p>
<h2>What constraints are and what they are not</h2>
<p>Constraints in Chipmunk are all velocity based constraints. This 
means that they act primarily by synchronizing the velocity of two 
bodies. A pivot joint holds two anchor points on two separate bodies 
together by defining equations that say that the velocity of the anchor 
points must be the same and calculating impulses to apply to the bodies 
to try and keep it that way. A constraint takes a velocity as it’s 
primary input and produces a velocity change as it’s output. Some 
constraints, (joints in particular) apply velocity changes to correct 
differences in positions. More about this in the next section.</p>
<p>A spring connected between two bodies is not a constraint. It’s very 
constraint-like as it creates forces that affect the velocities of the 
two bodies, but a spring takes distances as input and produces forces as
 it’s output. If a spring is not a constraint, then why do I have two 
varieties of spring constraints you ask? The reason is because they are <em>damped springs</em>.
 The damping associated with the spring is a true constraint that 
creates velocity changes based on the relative velocities of the two 
bodies it links. As it is convenient to put a damper and a spring 
together most of the time, I figured I might as well just apply the 
spring force as part of the constraint instead of having a damper 
constraint and having the user calculate and apply their own spring 
forces separately.</p>
<h2>Accessors</h2>
<ul>
	<li><code>a</code> – <code>CP::Body</code>: The first body that the constraint acts on.</li>
	<li><code>b</code> – <code>CP::Body</code>: The second body that the constraint acts on.</li>
	<li><code>maxForce</code> – <code>Float</code>: is the maximum force that the constraint can use to act on the two bodies. Defaults to <span class="caps">INFINITY</span>.</li>
	<li><code>biasCoef</code> – <code>Float</code>: is the percentage of 
error corrected each step of the space. (Can cause issues if you don’t 
use a constant time step) Defaults to 0.1.</li>
	<li><code>maxBias</code> – <code>Float</code>: is the maximum speed at which the constraint can apply error correction. Defaults to <span class="caps">INFINITY</span>.</li>
	<li><code>data</code> – <code>Object</code>: The Ruby bindings use this field internally, so it is not available for you use. It returns <code>self</code>, but that is not guaranteed.</li>
  <li><code>object</code> – <code>Object</code>: A user definable 
data object. If you set this to point at the game object the shapes is 
for, then you can access your game object from Chipmunk callbacks.</li>
</ul>
<p>To access properties of specific joint types, use the getter and setter functions provided (ex: <code>CP::PinJoint.anchr1</code>). See the lists of properties for more information.</p>
<h2>Error correction by Feedback</h2>
<p>Joints in Chipmunk are not perfect. A pin joint can’t maintain the 
exact correct distance between it’s anchor points, nor can a pivot joint
 hold it’s anchor points completely together. Instead, they are designed
 to deal with this by correcting themselves over time. In Chipmunk 5, 
you have a fair amount of extra control over how joints correct 
themselves and can even use this ability to create physical effects that
 allow you to use joints in unique ways:</p>
<ul>
	<li>Servo motors – Ex: open/close doors or rotate things without going over a maximum force.</li>
	<li>Winches – Pull one object towards another at a constant speed without going over a maximum force.</li>
	<li>Mouse manipulation – Interact with objects smoothly given coarse/shaky mouse input.</li>
</ul>
<p>There are three public fields of CP::Constraint structs that control the error correction, <code>max_force</code>, <code>max_bias</code>, and <code>bias_coef</code>. <code>max_force</code>
 is pretty self explanatory, a joint or constraint will not be able to 
use more than this amount of force in order to function. If it needs 
more force to be able to hold itself together, it will fall apart. <code>max_bias</code>
 is the maximum speed at which error correction can be applied. If you 
change a property on a joint so that the joint will have to correct 
itself, it normally does so very quickly. By setting a <code>max_speed
</code> you can make the joint work like a servo, correcting itself at a
constant rate over a longer period of time. 
Lastly, <code>bias_coef</code> is the percentage of error corrected every 
step before clamping to a maximum speed. You can use this to make joints
correct themselves smoothly instead of at a constant speed, but is probably 
the least useful of the three properties by far.</p>
<h2>Constraints and Collision Shapes</h2>
<p>Neither constraints or collision shapes have any knowledge of the 
other. When connecting joints to a body the anchor points don’t need to 
be inside of any shapes attached to the body and it often makes sense 
that they shouldn’t. Also, adding a constraint between two bodies 
doesn’t prevent their collision shapes from colliding. In fact, this is 
the primary reason that the collision group property exists.</p>
<h2>Video Tour of Current Joint Types. (Requires connection to YouTube)</h2>
<p><object type="shockwave/flash" height="344" width="425"><param name="movie" value="http://www.youtube.com/v/ZgJJZTS0aMM&amp;hl=en_US&amp;fs=1?rel=0"><param name="allow_full_screen" value="true"><param name="allowscriptaccess" value="always"><embed src="Chipmunk%20Game%20Dynamics%20Ruby%20Wrapper%20Documentation_files/ZgJJZTS0aMMhlen_USfs1.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" height="344" width="425"></object></p>
<h2>Misc Functions</h2>
<dl>
<dt><code>CP::Constraint#impulse</code></dt>
<dd>Get the most recent impulse that <code>constraint</code> applied. To convert this to a force, divide by the time step passed to <code>CP::Space#step()</code>.</dd>
</dl>
<a id="ConstraintTypes"></a>
<h1>Constraint Types</h1>
<h2>Pin Joints</h2>
<dl>
<dt><code>CP::PinJoint.new(a, b, anchr1, anchr2)</code></dt>
<dd><code>a</code> and <code>b</code> are the two bodies to connect, and <code>anchr1</code> and <code>anchr2</code>
 are the anchor points (Vect2) on those bodies. The distance between the two 
anchor points is measured when the joint is created. If you want to set a
 specific distance, use the setter function to override it.</dd>
</dl>
<table>
  <caption>PinJoint Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> anchr1 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> anchr2 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> dist </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Slide Joints</h2>
<dl>
<dt><code>CP::SlideJoint.new(a, b, anchr1, anchr2, min, max)</code></dt>
<dd><code>a</code> and <code>b</code> are the two bodies to connect, <code>anchr1</code> and <code>anchr2</code> are the anchor points on those bodies, and <code>min</code> and <code>max</code> define the allowed distances of the anchor points.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> anchr1 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> anchr2 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> Min </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> Max </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Pivot Joints</h2>
<dl>
<dt><code>CP::_pivot_joint *CP::_pivot_joint_alloc(void)
CP::_pivot_joint *CP::_pivot_joint_init(CP::_pivot_joint *joint, CP::Body *a, CP::Body *b, CP::Vec2 pivot)
CP::Constraint *CP::_pivot_joint_new(CP::Body *a, CP::Body *b, CP::Vec2 pivot)
CP::Constraint *CP::_pivot_joint_new2(CP::Body *a, CP::Body *b, CP::Vec2 anchr1, CP::Vec2 anchr2)</code></dt>
<dd><code>a</code> and <code>b</code> are the two bodies to connect, and <code>pivot</code>
 is the point in world coordinates of the pivot. Because the pivot 
location is given in world coordinates, you must have the bodies moved 
into the correct positions already. Alternatively you can specify the 
joint based on a pair of anchor points, but make sure you have the 
bodies in the right place as the joint will fix itself as soon as you 
start simulating the space.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> anchr1 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> anchr2 </td>
		<td> CP::Vec2 </td>
	</tr>
</tbody></table>
<h2>Groove Joints</h2>
<dl>
<dt><code>CP::GrooveJoint.new(a, *b, groove_a, groove_b, anchr2)</code></dt>
<dd>The groove goes from <code>groov_a</code> to <code>groove_b</code> on body <code>a</code>, and the pivot is attached to <code>anchr2</code> on body <code>b</code>. All coordinates are body local.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> anchr2 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> groove_a </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> groove_b </td>
		<td> CP::Vec2 </td>
	</tr>
</tbody></table>
<h2>Damped Spring</h2>
<dl>
<dt><code>CP::DampedSpring.new(a, b, anchr1, anchr2, restLength, stiffness,
damping)</code></dt>
<dd>Defined much like a slide joint. <code>restLength</code> is the distance the spring wants to be, <code>stiffness</code> is the spring constant (&gt;<a href="http://en.wikipedia.org/wiki/Young%27s_modulus">Young’s modulus</a>), and <code>damping</code> is how soft to make the damping of the spring.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> anchr1 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> anchr2 </td>
		<td> CP::Vec2 </td>
	</tr>
	<tr>
		<td> rest_length </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> stiffness </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> damping </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Damped Rotary Spring</h2>
<dl>
<dt><code>CP::DampedRotarySpring.new(a, b, restAngle, stiffness,
damping)</code></dt>
<dd>Like a damped spring, but works in an angular fashion. <code>restAngle</code> is the relative angle in radians that the bodies want to have, <code>stiffness</code> and <code>damping</code> work basically the same as on a damped spring.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> rest_angle </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> stiffness </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> damping </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Rotary Limit Joint</h2>
<dl>
<dt><code>CP::RotaryLimitJoint.new(a, b, min,max)</code></dt>
<dd>Constrains the relative rotations of two bodies. <code>min</code> and <code>max</code>
 are the angular limits in radians. It is implemented so that it’s 
possible to for the range to be greater than a full revolution.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> min </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> max </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Ratchet Joint</h2>
<dl>
<dt><code>CCP::RatchetJoint.new(a, b, phase, ratchet);</code></dt>
<dd>Works like a socket wrench. <code>ratchet</code> is the distance between “clicks”, <code>phase</code> is the initial offset to use when deciding where the ratchet angles are.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> angle </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> phase </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> ratchet </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Gear Joint</h2>
<dl>
<dt><code>CP::GearJoint.new(a, b, phase, ratio);</code></dt>
<dd>Keeps the angular velocity ratio of a pair of bodies constant. <code>ratio</code>
 is always measured in absolute terms. It is currently not possible to 
set the ratio in relation to a third body’s angular velocity. <code>phase</code> is the initial angular offset of the two bodies.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> phase </td>
		<td> Float </td>
	</tr>
	<tr>
		<td> ratio </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Simple Motor</h2>
<dl>
<dt><code>CP::SimpleMotor.new(a, b, Float rate);</code></dt>
<dd>Keeps the relative angular velocity of a pair of bodies constant. <code>rate</code>
 is the desired relative angular velocity. You will usually want to set 
an force (torque) maximum for motors as otherwise they will be able to 
apply a nearly infinite torque to keep the bodies moving.</dd>
</dl>
<table>
  <caption>Attributes List</caption>
	<tbody><tr>
		<th>Name </th>
		<th>Type </th>
	</tr>
	<tr>
		<td> rate </td>
		<td> Float </td>
	</tr>
</tbody></table>
<h2>Notes</h2>
<ul>
	<li>You can add multiple joints between two bodies, but make sure that 
they don’t fight. Doing so can cause the bodies jitter or spin 
violently.</li>
</ul>
<a id="CollisionDetection"></a>
<h1>Overview of Collision Detection in Chipmunk</h1>
<p>In order to make collision detection in Chipmunk as fast as possible,
 the process is broken down into several stages. While I’ve tried to 
keep it conceptually simple, the implementation can be a bit daunting. 
Fortunately as a user of the library, you don’t need to understand 
everything about how it works. If you are trying to squeeze every ounce 
of performance out of Chipmunk, understanding this section is crucial.</p>
<h2>Magic Collision Detection Globals</h2>
<p>The Chipmunk module CP contains variables that control how collisions 
are solved. They can’t be set on a per space basis, but most games wont 
need to change them at all.</p>
<dl>
<dt><code>CP.bias_coef</code></dt>
<dd>Because Chipmunk does not perform swept collisions, shapes may overlap. Each time you call <code>CP::Space#step()</code>
 Chipmunk fixes a percentage of the overlap to push the shapes apart. By
 default, this value is set to 0.1. With this setting, after 15 steps 
the overlap will be reduced to 20%, after 30 it will be reduced to 4%. 
This is usually satisfactory for most games. Setting CP::_bias_coef to 1.0
 is not recommended as it will reduce the stability of stacked objects.</dd>
<dt><code>CP.collision_slop</code></dt>
<dd>Chipmunk’s impulse solver works by caching the last 
solution as it is likely to be very similar to the current one. In order
 to help keep objects touching, Chipmunk allows objects to overlap a 
small amount. By default this value is 0.1. If you are using pixel 
coordinates you won’t even notice. If using a different scale, adjust 
the value to be as high as possible without creating any unwanted visual
 overlap.</dd>
<dt><code>CP.contact_persistence</code></dt>
<dd>This is how many steps the space should remember old 
contact solutions. The default value is 3 and it’s unlikely that you’ll 
need to change it.</dd>
</dl>
<h2>Spatial Hashing</h2>
<p>Chipmunk uses a spatial hash for its
 broad phase culling. Spatial hashes are very efficient for a scene made
 up of consistently sized objects. It basically works by taking the axis
 aligned bounding boxes for all the objects in the scene, mapping them 
onto an infinite sized grid, then mapping those grid cells onto a finite
 sized hash table. This way, you only have to check collisions between 
objects in the same hash table cells, and mapping the objects onto the 
grid can be done fairly quickly. Objects in the same hash table cells 
tend to be very close together, and therefore more likely to be 
colliding. The downside is that in order to get the best performance out
 of a spatial hash, you have to tune the size of the grid cells and the 
size of the hash table so you don’t get too many false positives. For 
more information about tuning the hash see the <a href="#Space">CP::Space</a> section.</p>
<p>Things to keep in mind:</p>
<ul>
	<li>Using too small a grid size means that your objects will be split 
into many grid cells which means that the spatial hash will spend a lot 
of time filling empty hash cells for just one object and rarely finding 
any with multiple objects. Making the grid size too big means that you 
will be putting a lot of objects into a single hash cell, and collisions
 will have to be checked between all of them.</li>
	<li>Using too small of a hash table means that you will map too many 
far away objects into a single hash cell. Using too many means that the 
hash table will have to spend a lot of time doing clears and rehashes.</li>
</ul>
<p>For more information on spatial hashing in general, <a href="http://www.beosil.com/download/_collision_detection_hashing_VMV03.pdf">Optimized Spatial Hashing for Collision Detection of Deformable Objects</a> is a good paper that covers all the basics.</p>
<h2>Collision Filtering</h2>
<p>After the spatial hash figures out pairs of shapes that are likely to
 be near each other, it passes them back to the space to perform some 
additional filtering on the pairs. If the pairs pass all the filters, 
then Chipmunk will test if the shapes are actually overlapping. If the 
shape to shape collision check passes, then the collision handler 
callbacks are called. These tests are much faster to try than the shape 
to shape collision checks, so use these if you can to reject collisions 
early instead of rejecting them from callbacks if you can.</p>
<ul>
	<li><strong>Bounding Box Test:</strong> The shapes are not colliding if
 their bounding boxes are not overlapping. You can’t really affect this,
 but this is when it’s done.</li>
	<li><strong>Layer Test:</strong> The shapes are not colliding if they don’t occupy and of the same layers. (the bitwise <span class="caps">AND</span> of their layer masks is 0)</li>
	<li><strong>Group Test:</strong> Shapes shouldn’t collide with other shapes in the same non-zero group.</li>
</ul>
<h2>Primitive Shape to Shape Collision Detection</h2>
<p>The most expensive test that you can do to see if shapes should 
collide is to actually check based on their geometry. Circle to circle 
and circle to line collisions are pretty quick. Poly to poly collisions 
get more expensive as the number of vertexes increases. Simpler shapes 
make for faster collisions (and more importantly fewer collision points 
for the solver to run).</p>
<h2>Collision Handler Filtering</h2>
<p>After checking if two shapes overlap Chipmunk will look to see if you
 have defined a collision handler for the collision types of the shapes.
 This gives you a large amount of flexibility to process collisions 
events, but also gives you a very flexible way to filter out collisions.</p>
<p> The return value of the begin and pre_solve callbacks determines whether 
or not the colliding pair of shapes is discarded or not. Returning true 
will keep the pair, false will discard it. If you don’t define a handler
 for the given collision_types, Chipmunk will call the space’s default 
handler, which by default is defined to simply accept all collisions.</p>
<p>While using callbacks to filter collisions is the most flexible way, 
keep in mind that by the time your callback is called all of the most 
expensive collision detection has already been done. For simulations 
with a lot of colliding objects each frame, the time spent finding 
collisions is small compared to the time spent solving the physics for 
them so it may not be a big deal. Still, use layers or groups first if 
you can.</p>
<a id="Callbacks"></a>
<h1>Callbacks</h1>
<p>A physics library without any events or feedback would not be very 
useful for games. How would you know when the player bumped into an 
enemy so that you could take some health points away? How would you know
 how hard the car hit something so you don’t play a loud crash noise 
when a pebble hits it? What if you need to decide if a collision should 
be ignored based on specific conditions, like implementing one way 
platforms? Chipmunk has a number of powerful callback systems that you 
can plug into to accomplish all of that.</p>
<h2>Collision Handlers</h2>
<p>The Ruby bindings support 2 types of collision handlers, namely a simple block, or a collision handler object.</p><p>

</p><h3>Collision Handler Blocks</h3>
<p>A collision handler block is a block that takes either 0, 1, 2, or 3 
arguments. These arguments may include the two colliding shapes, and an 
arbiter that describes the details of the collision. See<a href="#Arbiter">CP::Arbiter</a> for more info on arbiters.</p><p>
</p><p>Collision handler blocks are installed by calling <code>Space#add_collision_func(collision_type1, collision_type2) do ... end</code>. Depending on the arity of the handler block, different arguments will be passed:</p>
<table>
  <caption>Arguments passed</caption>
  <thead><tr><th>Arity</th><th>Signature</th><th>Passed</th></tr></thead>
  <tbody>
  <tr><td>0</td><td>do ... end</td><td>No arguments passed.</td></tr>
  <tr><td>1</td><td>do |arbiter| ... end</td><td>Arbiter passed.</td></tr>
  <tr><td>2</td><td>do |a,b|... end</td><td>Colliding shapes a and b passed.</td></tr>
  <tr><td>3</td><td>do |a,b,arbiter|... end</td><td>Colliding shapes a and b, and arbiter passed.</td></tr>
  </tbody>
</table>  
<p>A collision handler block will be called in the pre_solve step of the
 collision detection. Return false from the callback to make 
Chipmunk ignore the collision this step or true to process it normally.
</p>
<h3>Collision Handler Objects</h3>
<p>A collision handler object is an Object that responds_to? one or more
 of 4 distinct messages. Or, in other words, it's any object that has 
the one or more of 4 following methods for the different collision 
events that Chipmunk recognizes. The event types 
are:</p>
<ul>
	<li><code>begin</code> Two shapes just started touching for the 
first time this step. Return true from the callback to process the 
collision normally or false to cause Chipmunk to ignore the collision 
entirely. If you return false, the pre-solve and post-solve callbacks 
will never be run, but you will still receive a separate event when the 
shapes stop overlapping.</li>
	<li><strong>pre_solve:</strong> Two shapes are 
touching during this step. Return false from the callback to make 
Chipmunk ignore the collision this step or true to process it normally. 
Additionally, you may override collision values such as CP::Arbiter.e and 
CP::Arbiter.u to provide custom friction or elasticity values. See <a href="#Arbiter">CP::Arbiter</a> for more info.</li>
	<li><strong>post_solve:</strong> Two shapes are touching and their 
collision response has been processed. You can retrieve the collision 
force at this time if you want to use it to calculate sound volumes or 
damage amounts. See <a href="#Arbiter">CP::Arbiter</a> for more info.</li>
	<li><strong>separate</strong> Two shapes have just stopped touching for the first time this step.</li>
</ul>
<p>Depending on the arity of the mentioned methods, different arguments will be passed to them:</p>
<table>
  <caption>Arguments passed</caption>
  <thead><tr><th>Arity</th><th>Signature</th><th>Passed</th></tr></thead>
  <tbody>
  <tr><td>0</td><td>()</td><td>No arguments passed.</td></tr>
  <tr><td>1</td><td>(arbiter)</td><td>Arbiter passed.</td></tr>
  <tr><td>2</td><td>(a,b)</td><td>Colliding shapes a and b passed.</td></tr>
  <tr><td>3</td><td>(a,b,arbiter)</td><td>Colliding shapes a and b, and arbiter passed.</td></tr>
  </tbody>
</table> 
<p>The following is and example of a valid Collision Handler Object:</p>
<code>
<pre>class CollisionHandler
  def begin(a, b, arbiter)
  end
  
  def pre_solve(a, b)
  end
  
  def post_solve(arbiter)
  end
  
  def separate
  end
end
</pre>
</code>
<p>Collision callbacks are closely associated with <a href="#Arbiter">CP::Arbiter</a> structs. You should familiarize yourself with those as well.</p>
<p><strong>Note:</strong> Shapes tagged as sensors (<code>CP::Shape.sensor == true</code>)
 never generate collisions that get processed so collisions between 
sensors shapes and other shapes will never call the post-solve callback.
 They still generate begin, and separate callbacks, and the pre solve 
callback is also called every frame even though there is no real 
collision.</p>
<h2>Collision Handler <span class="caps">API</span></h2>
<dl>
<dt><code>CP::Space#add_collision_handler(collision_type_a, collision_type_b,
  collision_handler_object)</code>
  </dt>
<dd>Add a collision handler for given collision type pair. Whenever a shapes with collision type (<code>Symbol</code>) <code>a</code> and collision type <code>b</code> collide, the callbacks defined on <code>collision_handler_object</code> will be used to process the collision.</dd>
<dt><code>CP::Space#add_collision_handler(collision_type_a, collision_type_b, &amp;block)</code>
  </dt>
<dd>Add a collision handler block for given collision type pair. Whenever a shapes with collision type (<code>Symbol</code>) <code>a</code> and collision type <code>b</code> collide, the block will be called to process the collision.
</dd>
<dt><code>CP::Space#remove_collision_handler(collision_type a, collision_type b)</code></dt>
<dd>Remove a collision handler for a given collision type pair.</dd>
<dt><code> CP::Space.default_collision_handler(collision_type_a, 
collision_type_b,collision_handler_object),  
CP::Space.default_collision_handler(collision_type_a, 
collision_type_b,&amp;collision_handler_block)  </code></dt>
<dd>Register a default collision handler to be used when no 
specific collision handler is found. The space is given a default 
handler when created that returns true for all collisions in <code>begin</code> and <code>pre_solve</code> and does nothing in the <code>post_solve()</code> and <code>separate()</code> callbacks.</dd>
</dl>
<h2>Post-Step Callbacks</h2>
<p>Post-step callbacks are the one place where you can break the rules 
about adding or removing objects from within a callback. In fact, their 
primary function is to help you safely remove objects from the space 
that you wanted to disable or destroy in a collision callback.</p>
<p>Post step callbacks are registered as a function and a pointer that 
is used as a key. You can only register one post step callback per key. 
This prevents you from accidentally removing an object more than once. 
For instance, say that you get a collision callback between a bullet and
 object A. You want to destroy both the bullet and object A, so you 
register a post-step callback to safely remove them from your game. Then
 you get a second collision callback between the bullet and object B. 
You register a post-step callback to remove object B, and a second 
post-step callback to remove the bullet. Because you can only register 
one callback per key, the post-step callback for the bullet will only be
 called once and you can’t accidentally register to have it removed 
twice.</p>
<p>Note: Additional callbacks registered to the same key are ignored 
even if they use a different callback function or data pointer.</p>
<dl>
<dt><code>do |space, key| ... end </code></dt>
<dd>Block used for post step callbacks. <code>space</code> is the space the callback was registered on, <code>key</code> is the pointer value you supplied as the key</dd>
<dt><code>CP::Space.add_post_step_callback(key, &amp;block)</code></dt>
<dd>Add <code>block</code> to be called before <code>CP::Space#step()</code> returns. <code>self (CP::Space)</code> and <code>key (Object)</code> will be passed to your block, which must have the signature <code>do |space, key| ... end</code>. Only the last callback registered for any unique value of <code>key</code> will be recorded. You can add post-step callbacks from outside of other callback functions, but they won’t be called until <code>CP::Space#step()</code> is called again.</dd>
</dl>
<a id="Arbiter"></a>
<h1>Chipmunk Collision Pairs <code>CP::Arbiter</code></h1>
<p>First of all, why are they called arbiters? The short answer is that 
Box2D called them that way back in 2006 when Scott Lembcke was looking 
at the source for it’s solver. An arbiter is like a judge, a person 
that has authority to settle disputes between two people. It was a fun, 
fitting name and was shorter to type than CollisionPair which he had been using.
:p</p>
<p>Originally arbiters were going to be an internal data type that 
Chipmunk used that wouldn’t ever be sent to outside code. In Chipmunk 
4.x and earlier, only a single callback hook was provided for handling 
collision events. It was triggered every step that to shapes were 
touching. This made it non-trivial to track when objects started and 
stopped touching as the user would have to record and process this 
themselves. Many people, including myself, wanted to get collision 
begin/separate events and eventually I realized that information was 
already being stored in the arbiter cache that the Chipmunk maintains. 
With some changes to the collision callback <span class="caps">API</span>,
 that information is now exposed to the user. Internally, arbiters are 
used primarily for solving collision impulses. To external users, you 
can simply think of them as a weird type used in collision callbacks.</p>
<h2>Memory Management</h2>
<p>You should never need to create an arbiter, nor will you ever need to
free one as they are handled by the space. More importantly, because 
they are managed by the space you should never store a reference to an 
arbiter as you don’t know when they will be destroyed. Use them within 
the callback where they are given to you and then forget about them or 
copy out the information you need. <strong>This is even so in these Ruby
bindings!</strong>
</p>
<h2>Methods</h2>
<dl>
<dt><code>CP::Arbiter#shapes</code></dt>
<dd>Returns an array with the shapes in the order that they were defined in the
collision handler associated with this arbiter. If you defined the handler as
<code>CP::Space#add_collision_handler(space, 1, 2, ...)</code>,
you you will find that <code>a.collision_type == 1</code> and
<code>b.collision_type == 2</code>.</dd>
<dt><code>CP::Arbiter#first_contact?</code></dt>
<dd>Returns true if this is the first step that the shapes touched.
You can use this from <code>pre_solve()</code> and <code>post_solve()</code>
callbacks to know if a collision between two shapes is new without needing to
flag a Boolean in your <code>begin()</code> callback.</dd>
<dt><code>CP::Arbiter#points</code></dt>
<dd>Returns an Array of CP::ContactPoint with contact point information.
<strong>Note:</strong>calling this function from the <code>separate()</code>
callback is not allowed.</dd>
<dt><code>
CP::ContactPoint#point,
CP::ContactPoint#normal,
CP::ContactPoint#dist
</code></dt><dt>
</dt><dd>Accessors of the CP::ContactPoint struct, which return the Vec2 of the contact
point, the Vec2 normal, and the penetration distance, respectively.</dd>
<dt><code>CP::Arbiter.count</code> <code>CP::Arbiter.contacts</code></dt>
<dd>Returns the number of contact points in this arbiter.</dd>
<dt><code>CP::Arbiter.normal(i)</code></dt>
<dd>Returns the collision normal for the i’th contact point, flipping it if necessary. <strong>Note:</strong>
 Currently due to how Chipmunk’s collision detection is implemented, the
 collision normals will be the same for all collision points. You can 
simply do <code>CP::Arbiter.normal(0)</code> and not have to check each contact point. <strong>Note:</strong> calling this function from the <code>separate()</code> callback is undefined.</dd>
<dt><code>CP::Vec2 CP::Arbiter.point(i)</code></dt>
<dd>Returns the position of the i’th collision point. <strong>Note:</strong>
calling this function from the <code>separate()</code> callback is undefined.</dd>
<dt><code>CP::Vec2 CP::Arbiter.depth(i)</code></dt>
<dd>Returns the penetration depth of the i’th collision point.</dd>
<dt><code>CP::Vec2 CP::Arbiter.impulse(friction = nil)
</code></dt>
<dd>Returns the impulse that was applied this step to resolve the collision.
If friction is not nil, this method takes the friction value into consideration.
These functions should only be called from a <code>post_step()</code> callback,
otherwise the result is undefined. <strong>Note:</strong>
 If you are using the deprecated elastic iterations setting on your 
space, it will cause you to get incorrect results. Elastic iterations 
should no longer be needed, and you should be able to safely turn them 
off.</dd>
</dl>
<h2>Attributes</h2>
<p>It’s unlikely that you’ll need to interact with a <code>CP::Arbiter</code>
 struct directly as the collision helper functions should provide most 
functionality that people will need. One exception is the <code>e</code>,
and <code>u</code> attributes. By default, Chipmunk multiplies the friction
and elasticity values of to shapes together to determine what values to use when 
solving the collision. This mostly works, but in many cases is simply 
not flexible enough. If you are running into problems with that, you can
change the values calculated for <code>e</code> and <code>u</code> in a
preSolve callback. This is likely to change in the next major version of
Chipmunk.</p>
<ul>
  <li><code>contacts</code> – <code>Fixnum</code>: Number of contact points for this collision.</li>
  <li><code>e</code> – <code>Float</code>: Calculated amount of elasticity to apply for this collision. Can be overridden from a <code>preSolve()</code> callback.</li>
  <li><code>u</code> – <code>Float</code>: Calculated amount of friction to apply for this collision. Can be overridden from a <code>preSolve()</code> callback.</li>
  <li><code>surface_v</code> – <code>CP::Vec2</code>: Calculated amount of surface velocity to apply for this collision. Can be overridden from a <code>pre_solve()</code> callback. (<em>Very</em> likely to change in the next major version of Chipmunk).</li>
</ul>
<a id="Queries"></a>
<h1>Queries</h1>
<p>Chipmunk spaces currently support three kinds 
of spatial queries, point, segment and bounding box. Any type can be 
done efficiently against an entire space, or against individual shapes. 
All types of queries take a collision group and layer that are used to 
filter matches out using the same rules used for filtering collisions 
between shapes. See <a href="#Shape">CP::Shape</a> for more information. If you don’t want to filter out any matches, use <code>CP::ALL_LAYERS</code> for the layers and <code>CP::NO_GROUP</code> 
as the group.</p>
<h2>Point Queries</h2>
<p>Point queries are useful for things like mouse picking and simple sensors.</p>
<dl>
<dt><code>CP::Shape.point_query(p)</code></dt>
<dd>Check if the given point (CP::Vec2) lies within the shape.</dd>
<dt><code>CP::Space.point_query(point,layers, group) do |shape| ... end
</code></dt>
<dd>Query <code>space</code> at <code>point</code> filtering out matches with the given <code>layers</code> and <code>group</code>. The given block is called for each shape found with <code>shape</code> as argument. Sensor shapes are included.</dd>
<dt><code>CP::Space.point_query_first(point, layers, group)</code></dt>
<dd>Query <code>space</code> at <code>point</code> and return the first shape found matching the given <code>layers</code> and <code>group</code>. Returns <code>nil</code> if no shape was found.  Sensor shapes are ignored.</dd>
</dl>
<h2>Segment Queries</h2>
<p>Segment queries are like ray casting, but because Chipmunk uses a 
spatial hash to process collisions, it cannot process infinitely long 
queries like a ray. In practice this is still very fast and you don’t 
need to worry too much about the performance as long as you aren’t using
 extremely long segments for your queries.</p>
<dl>
<dt><code>CP::SegmentQueryInfo is a Ruby Struct with the following members:
	shape:  shape that was hit, nil if no collision.
	t: Distance along query segment, will always be in the range 0..1 .
	n: Normal of hit surface.
</code></dt>
<dd>Segment queries return more information than just a 
simple yes or no, they also return where a shape was hit and it’s 
surface normal at the hit point. <code>t</code> is the percentage 
between the query start and end points. If you need the hit point in 
world space or the absolute distance from start, see the segment query 
helper functions farther down.</dd>
<dt><code>CP::Shape.segment_query(a, b) </code></dt>
<dd>Check if the line segment from <code>a</code> to <code>b</code> intersects the shape. Returns a CP::SegmentQueryInfo struct with the results of the query. </dd>
<dt><code>
CP::Space#segment_query(start, stop, layers, group) do |shape, t, n|
</code></dt>
<dd>Query <code>space</code> along the line segment from <code>start</code> to <code>stop</code> filtering out matches with the given <code>layers</code> and <code>group</code>.
 The block is called with the shape found, the normalized distance along
 the line and surface normal for each shape found.  Sensor shapes are 
included.</dd>
<dt><code>CP::Space#segment_query_first(start, stop, layers, group)
</code></dt>
<dd>Query <code>space</code> along the line segment from <code>start</code> to <code>stop</code> filtering out matches with the given <code>layers</code> and <code>group</code>. Only the first shape encountered is returned and the search is short circuited. Returns <code>nil</code>
 if no shape was found. Otherwise returns a CP::SegmentQueryInfo struct 
with the results of the query. Sensor shapes are ignored.</dd>
</dl>
<h3>Segment Query Helper Functions</h3>
<dl>
<dt><code>CP::SegmentQueryInfo#hit_point(start, stop)</code></dt>
<dd>Return the hit point in world coordinates where the segment first intersected with the shape.</dd>
<dt><code>CP::SegmentQueryInfo#hit_dist(start, stop)</code></dt>
<dd>Return the absolute distance where the segment first hit the shape.</dd>
</dl>

</body></html>